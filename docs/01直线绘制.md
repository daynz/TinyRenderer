# 直线绘制算法笔记
## 一、DDA 算法
### （一）步骤
1. 先算出两点在 x 方向和 y 方向的差值，分别记为 dx 和 dy。
2. 确定绘制直线的步数（step），取 dx 和 dy 中绝对值较大的那个。
3. 计算 x 和 y 方向上每步移动的增量，即 xInc 和 yInc。
4. 按照步数值循环，每次循环把当前点设置为指定颜色，同时更新 x 和 y 的坐标值。

### （二）缺点
1. **浮点运算问题**：计算增量时依赖浮点运算，在一些硬件上速度比整数运算慢。
2. **精度不足**：浮点数表示不精确，多次迭代后舍入误差可能使直线末端出现偏差。
3. **效率欠佳**：某些情况下不如 Bresenham 算法高效，后者只用整数运算，速度更快更准确。
4. **步进决策弊端**：依据差值选步进数，可能导致绘制点数多于实际需求。
5. **不支持斜率特性**：基于差值计算，不像基于斜率的算法那么直观，不直接支持直线斜率。
6. **内存占用较多**：绘制大量直线时，浮点数比整数占用更多内存，在资源受限环境下是个问题。
7. **特殊情况劣势**：绘制非常陡峭的直线时不是最佳选择，可能在末端多绘点。
8. **抗锯齿缺失**：不直接支持抗锯齿，在高分辨率显示设备上直线边缘易呈锯齿状。
9. **实现复杂情况**：虽整体实现相对简单，但处理浮点数增加了复杂度，比纯整数运算算法复杂。

## 二、Bresenham 算法
### （一）多次尝试过程
1. **第一次尝试**：最初绘制线段的简单代码是在 0 到 1 之间按一定步长（如 0.01）取 t 值，计算出对应的 x 和 y 坐标，然后在图像上绘制相应像素点，但效率很低。
2. **第二次尝试**：将步长设为 0.1 后线段绘制效果改变。还尝试根据像素数确定步长，但出现整数除法问题，如 `(x - x0)/(x1 - x0)`，且绘制不同方向的相同线段时出现线段缺失或绘制不出的情况，且无法保证对称性。
3. **第三次尝试**：通过交换点使 x0 小于 x1 修复部分问题，对于陡峭线段还进行转置处理，但代码效率仍不高，存在多次除法等问题，且缺少边界检查等。
4. **第四次尝试（计时分析）**：测试发现代码中 `line()` 函数调用和颜色复制构造函数调用占用大量时间，需对 `line()` 函数进行优化。
5. **第五次尝试**：把每次循环中相同的除数从循环里拿出来，引入误差变量，根据误差与 0.5 的比较来调整 y 坐标，减少了浮点运算次数，提高了效率。
6. **第六次及最终尝试（计时优化）**：进一步用新变量替换误差变量，完全去掉浮点数运算，只进行整数运算，同时通过传递颜色引用避免不必要的副本，执行时间大幅减少。

### （二）算法原理
依据直线斜率（m，即垂直变化量 Δy 与水平变化量 Δx 的比率）来决定绘制方式，核心是用决策参数（误差值）确定在给定 x 坐标下应选的 y 坐标。

### （三）算法步骤
1. **初始化**：算出直线起点 `(x0, y0)` 和终点 `(x1, y1)` 的水平差 `Δx` 和垂直差 `Δy`。
2. **确定步进方向**：根据 `Δx` 和 `Δy` 的符号确定 x 和 y 方向的步进方向（sx 和 sy）。
3. **初始化误差值**：计算初始误差值 err，它是 `Δx` 和 `Δy` 的函数。
4. **绘制起点**：在 `(x0, y0)` 绘制一个像素。
5. **迭代绘制**：重复以下操作直至到达终点。先计算新误差值（若步进在 x 方向则 err += 2*Δy，若在 y 方向则 err += 2*Δx）；若新误差值大于 0，调整 y 坐标（根据斜率和 x 步进方向增减）并更新误差值（若 x 方向步进则 err -= 2*Δx，若 y 方向步进则 err -= 2*Δy）；最后更新 x 坐标。
6. **终止**：到达终点时停止迭代。

### （四）优点
1. **整数运算优势**：全程使用整数算术，早期计算机上因浮点运算慢，此优势显著。
2. **简单高效特性**：逻辑简单易实现，执行速度快，适合硬件实现。
3. **内存占用少**：只需维护少量变量，无需大量存储中间数据。
4. **适应能力强**：能处理任意斜率直线，包括水平和垂直线。
5. **无抖动效果**：绘制直线平滑无锯齿。
6. **灵活可扩展**：容易修改用于绘制圆和其他曲线。

### （五）缺点
1. **不抗锯齿问题**：生成直线未做抗锯齿处理，高分辨率设备上不够平滑。
2. **精度受限情况**：仅用整数运算，直线斜率接近 1:1 时可能无法精确表示。
3. **扩展有难度**：处理大或小斜率直线时可能需额外逻辑。
4. **性能优势减**：现代计算机浮点运算快，其性能优势不突出。
5. **不支持浮点**：不适用于浮点坐标直线，需转换为整数。
6. **复杂情况**：斜率绝对值大于 1 的直线需额外步骤，增加实现复杂度。
7. **并非全能**：在某些特定图形硬件或库中，可能有更优直线绘制方法。

## 三、线框渲染
使用 `wavefront obj` 格式文件存储模型，文件中每行一个顶点（含 x、y、z 坐标）或面信息（如 `f 1193/1240/1193 1180/1227/1180 1179/1226/1179`，关注空格后第一位数字作为顶点编号，索引从 1 开始，实际需找对应减 1 的顶点）。在 `main.cpp` 中通过以下循环实现线框渲染：

```cpp
for (int i = 0; i < model->nfaces(); i++) 
{ 
    std::vector<int> face = model->face(i); 
    for (int j = 0; j < 3; j++) 
    { 
        Vec3f v0 = model->vert(face[j]); 
        Vec3f v1 = model->vert(face[(j + 1)%3]); 
        int x0 = (v0.x + 1.)*width/2.; 
        int y0 = (v0.y + 1.)*height/2.; 
        int x1 = (v1.x + 1.)*width/2.; 
        int y1 = (v1.y + 1.)*height/2.; 
        line(x0, y0, x1, y1, image, white); 
    } 
}
```